{
  "title": "Chronosync",
  "description": "A full-stack solution for synchronizing data across multiple platforms.",
  "skills": ["Vue.js", "Express", "Backend", "Frontend", "Web Dev", "Software Dev", "C++", "PowerShell"],
  "overview": "ChronoSync represents a modern approach to time management, specifically designed for developers and creative professionals. The application seamlessly integrates web and desktop technologies to provide a unified experience across all platforms.",
  "sections": {
    "architecture": {
      "title": "Architecture",
      "content": {
        "paragraph1": "Figure 2 shows a screenshot of the 'packages' folder from ChronoSync's GitHub repository. It contains four directories: desktop, mobile, web, and shared. Each corresponds to a different version of the application (desktop, mobile, and web browser), while the shared folder contains common code used across all platforms. This demonstrates the use of a mono-repository structure - a single project grouping all platforms together, making it easy to share code.",
        "paragraph2": "As indicated in the caption, this mono-repository was set up using Nx, a tool designed to organize this type of project, and pnpm, a modern package manager used to install, compile, and manage different parts of the application. This structure enables parallel development across multiple platforms while maintaining overall project coherence.",
        "paragraph3": "This organization demonstrates a solid understanding of multi-platform architecture. Grouping different versions of the application within a single repository allows for code reuse, centralizes business logic, and limits duplication. It also facilitates project scalability and simplifies synchronization between teams or modules. While I've only experienced this architecture in this project, I feel capable of effectively integrating into or contributing to other similarly structured projects.",
        "paragraph4": "The choice of pnpm over npm or yarn aligns with performance and maintainability goals. In a JavaScript/TypeScript project, the package manager is an essential tool for installing and organizing project libraries. I chose pnpm for its concrete advantages: fast installation, disk space efficiency through symlinks, and better dependency management. This allowed me to effectively manage multiple packages in parallel within a mono-repo environment while maintaining consistent versions. I now consider myself quite proficient in using package managers like pnpm, npm, or bun, having used them in most of my personal and professional projects, particularly when creating websites like task managers.",
        "paragraph5": "The implementation of the shared package demonstrates a clear intention to optimize project structure. This module contains common functions, types, or models used across all platforms, ensuring uniform logic and reducing errors or inconsistencies. However, I believe I still have room for improvement in using this type of package, particularly when sharing code between different technologies or languages - an aspect I didn't explore deeply in this project. On the other hand, regarding general code modularity, I believe I have a good level of expertise. For example, in my 'Power X' project, a video game developed in Java, I applied the MVC pattern, which helped me better organize the code and make it more readable and maintainable."
      }
    },
    "expressApi": {
      "title": "Express.js API Implementation",
      "content": {
        "paragraph1": "Figure 3 is a screenshot of the appUsage.ts file, a TypeScript file that defines backend routes for the ChronoSync application. This file is part of the API developed with Express.js, a framework for creating web servers with JavaScript. An API (Application Programming Interface) is a set of entry points (called routes) that the client (application on phone, computer, or browser) can use to request data from the server. In this specific case, we observe five routes, each allowing retrieval of usage statistics (time spent on each application) according to different periods: daily, weekly, monthly, yearly, and custom.",
        "paragraph2": "The implementation of these five routes demonstrates an understanding of how a REST API works with Express.js. Each route is designed to respond to a specific client request: for example, getting all applications used during a day or over a date range defined by the user. I was able to structure these entry points clearly, grouping them by business logic (here: application usage), which makes the code more readable and easier to maintain. This structuring is essential in a long-term or collaborative project, as it allows other developers to quickly understand the role of each part of the code. My level in using Express.js to create routes is still limited, as this project is the only one where I was able to discover and learn this framework. However, I am capable of understanding and modifying a project that uses this technology without too much difficulty.",
        "paragraph3": "This logical grouping in a single file (appUsage.ts) also illustrates good backend organization around a single business concept. This facilitates the implementation of global controls, such as user authentication verification or parameter validation, which can apply to all routes without code duplication. This modular approach improves code maintainability in the long term. As we have seen in other projects I have presented in this portfolio, such as Power X with the MVC model, I think I master the modular approach when developing in most languages.",
        "paragraph4": "The use of dynamic parameters, particularly for the custom route, shows an ability to design flexible routes capable of responding to complex requests. In this route, the client can for example send two specific dates, and the server will return only the data corresponding to this interval. This gives the user great freedom in consulting their statistics, while keeping unified logic on the server side. My level in managing custom parameters in an API, as with APIs in general, is still limited, due to a lack of varied practical experiences.",
        "paragraph5": "Finally, the fact that this backend serves a multi-platform application (web, desktop, mobile) shows that I was able to design a coherent API for heterogeneous clients. All platforms consume the same routes, which guarantees that data is uniform and synchronized, regardless of the medium used by the user. This ability to design a central data point for multiple interfaces is a real advantage in cross-platform projects."
      }
    }
  }
}